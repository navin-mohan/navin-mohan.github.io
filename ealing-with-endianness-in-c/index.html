<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Dealing with endianness in C++ | Navin Mohan</title>
<meta name=keywords content>
<meta name=description content="If you have ever dealt with binary data, then the chances are that you must have come across the term endianness at least once.
Let&rsquo;s take a deeper dive and see how you can keep your bytes in order.
If you&rsquo;re here for the code, then skip ahead to methods.
What is endianness? Endianness is basically the sequential order in which bytes are organized in a word. Generally, the computer memory is byte addressable therefore it doesn&rsquo;t care how the constituent bytes are organized.">
<meta name=author content="Navin Mohan">
<link rel=canonical href=https://navinmohan.com/ealing-with-endianness-in-c/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://navinmohan.com/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://navinmohan.com/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=https://navinmohan.com/favicon.ico>
<link rel=apple-touch-icon href=https://navinmohan.com/favicon.ico>
<link rel=mask-icon href=https://navinmohan.com/favicon.ico>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3MBG0NNR14"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-3MBG0NNR14',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Dealing with endianness in C++">
<meta property="og:description" content="If you have ever dealt with binary data, then the chances are that you must have come across the term endianness at least once.
Let&rsquo;s take a deeper dive and see how you can keep your bytes in order.
If you&rsquo;re here for the code, then skip ahead to methods.
What is endianness? Endianness is basically the sequential order in which bytes are organized in a word. Generally, the computer memory is byte addressable therefore it doesn&rsquo;t care how the constituent bytes are organized.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://navinmohan.com/ealing-with-endianness-in-c/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-12-31T00:00:00+00:00">
<meta property="article:modified_time" content="2018-12-31T00:00:00+00:00"><meta property="og:site_name" content="Navin Mohan">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Dealing with endianness in C++">
<meta name=twitter:description content="If you have ever dealt with binary data, then the chances are that you must have come across the term endianness at least once.
Let&rsquo;s take a deeper dive and see how you can keep your bytes in order.
If you&rsquo;re here for the code, then skip ahead to methods.
What is endianness? Endianness is basically the sequential order in which bytes are organized in a word. Generally, the computer memory is byte addressable therefore it doesn&rsquo;t care how the constituent bytes are organized.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://navinmohan.com/posts/"},{"@type":"ListItem","position":2,"name":"Dealing with endianness in C++","item":"https://navinmohan.com/ealing-with-endianness-in-c/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dealing with endianness in C++","name":"Dealing with endianness in C\u002b\u002b","description":"If you have ever dealt with binary data, then the chances are that you must have come across the term endianness at least once.\nLet\u0026rsquo;s take a deeper dive and see how you can keep your bytes in order.\nIf you\u0026rsquo;re here for the code, then skip ahead to methods.\nWhat is endianness? Endianness is basically the sequential order in which bytes are organized in a word. Generally, the computer memory is byte addressable therefore it doesn\u0026rsquo;t care how the constituent bytes are organized.","keywords":[],"articleBody":"If you have ever dealt with binary data, then the chances are that you must have come across the term endianness at least once.\nLet’s take a deeper dive and see how you can keep your bytes in order.\nIf you’re here for the code, then skip ahead to methods.\nWhat is endianness? Endianness is basically the sequential order in which bytes are organized in a word. Generally, the computer memory is byte addressable therefore it doesn’t care how the constituent bytes are organized.\n “Endianness refers to the sequential order in which bytes are arranged into larger numerical values when stored in memory or when transmitted over digital links” Wikipedia\n However, the processor often works with multiple bytes of data depending on its word length. For instance, a 64-bit CPU can process 8-byte data words. Hence, the ordering becomes important as any inconsistency will result in unexpected results.\nSo you might be wondering why can’t we just stick to the order in which most of us write a numeric value i.e. starting with the most significant byte(MSB) and ending with the least significant byte (LSB) also known as “Big-Endian” ordering. In fact, that is perfectly fine but as with most things in the computer industry, some vendors choose to go the other way. In those systems, the word starts with the LSB and ends with the MSB.\nWhat determines the endianness of a system? As we have seen earlier the memory(main memory) doesn’t care in what order the words are stored since all the bytes are individually addressed. Therefore it has got nothing to do with the endianness of the system.\nThe CPU, on the other hand, is designed in such a way that it expects the data words to be in a specific order. Hence, it determines the endianness in use.\nThe popular x86 architecture uses little-endian byte ordering.\nChecking the endianness of your system It is pretty easy to check the endianness of a system. Just see where the MSB of a value is in memory.\n#include #include  // uint16_t and uint8_t using namespace std; bool isBigEndian(){ uint16_t word = 1; // 0x0001  uint8_t *first_byte = (uint8_t*) \u0026word; // points to the first byte of word  return !(*first_byte); // true if the first byte is zero } int main(){ cout  (isBigEndian()?\"Big-Endian\":\"Little-Endian\")  endl; return 0; } Why should you care about endianness? We are not writing assembly anymore then why are we concerned about such a low-level detail. Well, the compiler takes care of most of the heavy-lifting but there are certain cases where the developer’s attention is required. The following are the two common cases.\nHandling binary files Binary files have a standard software representation which may or may not match with the endianness of your system. Therefore it needs to be handled accordingly by the developer.\nFor instance, a JPEG file uses big-endian format with a word size of 16-bits.\nData transfer over a network Here the network protocols define the endianness of the transmitted data so that multiple systems on the network can safely agree on the data being communicated. The developer has to make sure that it is maintained irrespective of the system.\nIn TCP/IP, big-endian ordering is used as a convention and it might vary depending on the application protocol.\nMethods for handling endianness in C++ There are many ways in which you can switch between native and standard byte ordering. A few of the common methods are listed below:\nUse the socket programming API One of the easiest ways to convert between byte orderings is to use the socket programming API which comes with a set of handy functions\n uint16_t htons(uint16_t hostshort) - converts host byte order to network byte order. uint16_t ntohs(uint16_t hostshort) - converts network byte order to host byte order.  The network byte order is always big-endian by convention.\nIf your system is little-endian (host byte order) the above functions will perform the necessary byte swapping otherwise they just return the same value.\nSimilarly, htonl and ntohl handles a 32-bit word.\n#include #include  // htonl#include  // uint32_t and uint8_t /* The expected output on a little-endian system: 00EEFFAA AAFFEE00 */ using namespace std; void show_memory_representation(const uint8_t* firstbyte,const int length){ for(int i=0;ilength;++i){ printf(\"%.2X\",*(firstbyte + i)); } printf(\"\\n\"); } int main(){ uint32_t hostlong = 0xAAFFEE00; uint32_t netlong; show_memory_representation((uint8_t*)\u0026hostlong,sizeof(hostlong)); netlong = htonl(hostlong); show_memory_representation((uint8_t*)\u0026netlong,sizeof(netlong)); return 0; } Use Boost.Endian library The Boost library offers a rich set of function to manipulate the endianness of integers and user-defined types.\n#include #include #include  // uint8_t,uint32_t#include  // order, endian_reverse using namespace std; /* Output on a little endian system: Little-Endian Native order: DDCCBBAA Native order reversed: AABBCCDD Native order converted to big endian: AABBCCDD Native order converted to little endian: DDCCBBAA Little-endian order converted to native: DDCCBBAA Big-endian order converted to native: DDCCBBAA */ void show_memory_representation(const uint8_t* firstbyte,const int length){ for(int i=0;ilength;++i){ printf(\"%.2X\",*(firstbyte + i)); } printf(\"\\n\"); } int main(){ // testing the endianness  if(boost::endian::order::native == boost::endian::order::big){ cout  \"Big-Endian\"  endl; }else if(boost::endian::order::native == boost::endian::order::little){ cout  \"Little-Endian\"  endl; } // word is in native byte order  uint32_t word = 0xAABBCCDD; cout  \"Native order:\"  endl; show_memory_representation((uint8_t*)\u0026word,sizeof(word)); // reverses the current order  uint32_t reversed_word = boost::endian::endian_reverse(word); cout  \"Native order reversed:\"  endl; show_memory_representation((uint8_t*)\u0026reversed_word,sizeof(reversed_word)); // converts native order to big endian  uint32_t big_word = boost::endian::native_to_big(word); cout  \"Native order converted to big endian:\"  endl; show_memory_representation((uint8_t*)\u0026big_word,sizeof(big_word)); // converts native order to little endian  uint32_t little_word = boost::endian::native_to_little(word); cout  \"Native order converted to little endian:\"  endl; show_memory_representation((uint8_t*)\u0026little_word,sizeof(little_word)); // converts little endian order to native  uint32_t native_word = boost::endian::little_to_native(little_word); cout  \"Little-endian order converted to native:\"  endl; show_memory_representation((uint8_t*)\u0026native_word,sizeof(native_word)); // converts big endian order to native  native_word = boost::endian::big_to_native(big_word); cout  \"Big-endian order converted to native:\"  endl; show_memory_representation((uint8_t*)\u0026native_word,sizeof(native_word)); return 0; } I think the example program is pretty much self-explanatory and Boost.Endian comes with a lot of bells and whistles. Therefore covering all of them in a single blog post is impossible. You can find the official documentation here for more details.\nBuild your own container If you need even more control, you could just use a standard C++ union to roll out your own.\nHere, we are using the property of a union which shares the allocated memory between all of its elements. Which means it can only hold one of its non-static data members at any given time.\nWe will also use some operator overloading to make things simpler.\n#include #include  //uint8_t, uint32_t using namespace std; /* The expected output on a little-endian system: Actual memory representation: DDCCBBAA Expecting little-endian, storing as big-endian AABBCCDD Expecting little-endian, storing as little-endian DDCCBBAA Expecting big-endian, storing as big-endian DDCCBBAA Expecting big-endian, storing as little-endian AABBCCDD */ enum ENDIANNESS{ little, big }; templatetypename T,ENDIANNESS from, ENDIANNESS to struct Word{ /* anonymous union makes sure that the data and ** byte[] occupy the same memory location */ union{ T data; uint8_t byte[sizeof(T)]; }; uint8_t\u0026 operator[](int i){ if(from == to){ return byte[i]; }else{ /* flip the order only if the source and destination has ** different ordering */ return byte[sizeof(T) - i - 1]; } } }; // a helper function to show how the actual memory representatiom void show_memory_representation(const uint8_t* firstbyte,const int length){ for(int i=0;ilength;++i){ printf(\"%.2X\",*(firstbyte + i)); } printf(\"\\n\"); } int main(){ Worduint32_t,ENDIANNESS::little,ENDIANNESS::big w; Worduint32_t,ENDIANNESS::little,ENDIANNESS::little w1; Worduint32_t,ENDIANNESS::big,ENDIANNESS::big w2; Worduint32_t,ENDIANNESS::big,ENDIANNESS::little w3; // our data source which will be using the system endianness in this case  uint32_t source = 0xAABBCCDD; cout  \"Actual memory representation:\"  endl; show_memory_representation((uint8_t*)\u0026source,4); // to iterate through the data source (could be a file pointer)  uint8_t *ptr = (uint8_t*)\u0026source; for(int i=0;i4;++i){ w[i] = *(ptr + i); w1[i] = *(ptr + i); w2[i] = *(ptr + i); w3[i] = *(ptr + i); } cout  \"Expecting little-endian, storing as big-endian\"  endl; show_memory_representation((uint8_t*)\u0026w.data,4); cout  \"Expecting little-endian, storing as little-endian\"  endl; show_memory_representation((uint8_t*)\u0026w1.data,4); cout  \"Expecting big-endian, storing as big-endian\"  endl; show_memory_representation((uint8_t*)\u0026w2.data,4); cout  \"Expecting big-endian, storing as little-endian\"  endl; show_memory_representation((uint8_t*)\u0026w3.data,4); return 0; } You could use it with pretty much any built-in or user-defined datatype. And by no means, this is the best possible implementation out there. This is just something I came up with when I had a requirement. If you know a better way of implementing it, feel free to let me know in the comments.\nThank you for reading! 😀\n","wordCount":"1391","inLanguage":"en","datePublished":"2018-12-31T00:00:00Z","dateModified":"2018-12-31T00:00:00Z","author":{"@type":"Person","name":"Navin Mohan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://navinmohan.com/ealing-with-endianness-in-c/"},"publisher":{"@type":"Organization","name":"Navin Mohan","logo":{"@type":"ImageObject","url":"https://navinmohan.com/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://navinmohan.com/ accesskey=h title="Navin Mohan (Alt + H)">Navin Mohan</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://navinmohan.com/about/ title=about>
<span>about</span>
</a>
</li>
<li>
<a href=https://navinmohan.com/contact/ title=contact>
<span>contact</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://navinmohan.com/>Home</a>&nbsp;»&nbsp;<a href=https://navinmohan.com/posts/>Posts</a></div>
<h1 class=post-title>
Dealing with endianness in C++
</h1>
<div class=post-meta>December 31, 2018&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Navin Mohan
</div>
</header>
<div class=post-content><p>If you have ever dealt with binary data, then the chances are that you must have come across the term endianness at least once.</p>
<p>Let&rsquo;s take a deeper dive and see how you can keep your bytes in order.</p>
<p>If you&rsquo;re here for the code, then skip ahead to <a href=#methods-for-handling-endianness-in-c>methods</a>.</p>
<h2 id=what-is-endianness>What is endianness?<a hidden class=anchor aria-hidden=true href=#what-is-endianness>#</a></h2>
<p>Endianness is basically the sequential order in which bytes are organized in a word. Generally, the computer memory is byte addressable therefore it doesn&rsquo;t care how the constituent bytes are organized.</p>
<blockquote>
<p>&ldquo;Endianness refers to the sequential order in which bytes are arranged into larger numerical values when stored in memory or when transmitted over digital links&rdquo; <a href=https://en.wikipedia.org/wiki/Endianness>Wikipedia</a></p>
</blockquote>
<p>However, the processor often works with multiple bytes of data depending on its word length. For instance, a 64-bit CPU can process 8-byte data words. Hence, the ordering becomes important as any inconsistency will result in unexpected results.</p>
<p>So you might be wondering why can&rsquo;t we just stick to the order in which most of us write a numeric value i.e. starting with the most significant byte(MSB) and ending with the least significant byte (LSB) also known as &ldquo;Big-Endian&rdquo; ordering. In fact, that is perfectly fine but as with most things in the computer industry, some vendors choose to go the other way. In those systems, the word starts with the LSB and ends with the MSB.</p>
<p><img loading=lazy src=/img/2018-12-31-dealing-with-endianess-cpp/endian.png alt=Example>
</p>
<h3 id=what-determines-the-endianness-of-a-system>What determines the endianness of a system?<a hidden class=anchor aria-hidden=true href=#what-determines-the-endianness-of-a-system>#</a></h3>
<p>As we have seen earlier the memory(main memory) doesn&rsquo;t care in what order the words are stored since all the bytes are individually addressed. Therefore it has got nothing to do with the endianness of the system.</p>
<p>The CPU, on the other hand, is designed in such a way that it expects the data words to be in a specific order. Hence, it determines the endianness in use.</p>
<p>The popular <strong>x86</strong> architecture uses little-endian byte ordering.</p>
<h2 id=checking-the-endianness-of-your-system>Checking the endianness of your system<a hidden class=anchor aria-hidden=true href=#checking-the-endianness-of-your-system>#</a></h2>
<p>It is pretty easy to check the endianness of a system. Just see where the MSB of a value is in memory.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt; // uint16_t and uint8_t</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isBigEndian</span>(){
    <span style=color:#66d9ef>uint16_t</span> word <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 0x0001
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>first_byte <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>) <span style=color:#f92672>&amp;</span>word; <span style=color:#75715e>// points to the first byte of word
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span>(<span style=color:#f92672>*</span>first_byte); <span style=color:#75715e>// true if the first byte is zero
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
    cout <span style=color:#f92672>&lt;&lt;</span> (isBigEndian()<span style=color:#f92672>?</span><span style=color:#e6db74>&#34;Big-Endian&#34;</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#34;Little-Endian&#34;</span>) <span style=color:#f92672>&lt;&lt;</span> endl;
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

</code></pre></div><h2 id=why-should-you-care-about-endianness>Why should you care about endianness?<a hidden class=anchor aria-hidden=true href=#why-should-you-care-about-endianness>#</a></h2>
<p>We are not writing assembly anymore then why are we concerned about such a low-level detail. Well, the compiler takes care of most of the heavy-lifting but there are certain cases where the developer&rsquo;s attention is required. The following are the two common cases.</p>
<h3 id=handling-binary-files>Handling binary files<a hidden class=anchor aria-hidden=true href=#handling-binary-files>#</a></h3>
<p>Binary files have a standard software representation which may or may not match with the endianness of your system. Therefore it needs to be handled accordingly by the developer.</p>
<p>For instance, a JPEG file uses big-endian format with a word size of 16-bits.</p>
<h3 id=data-transfer-over-a-network>Data transfer over a network<a hidden class=anchor aria-hidden=true href=#data-transfer-over-a-network>#</a></h3>
<p>Here the network protocols define the endianness of the transmitted data so that multiple systems on the network can safely agree on the data being communicated. The developer has to make sure that it is maintained irrespective of the system.</p>
<p>In TCP/IP, big-endian ordering is used as a convention and it might vary depending on the application protocol.</p>
<h2 id=methods-for-handling-endianness-in-c>Methods for handling endianness in C++<a hidden class=anchor aria-hidden=true href=#methods-for-handling-endianness-in-c>#</a></h2>
<p>There are many ways in which you can switch between native and standard byte ordering. A few of the common methods are listed below:</p>
<h3 id=use-the-socket-programming-api>Use the socket programming API<a hidden class=anchor aria-hidden=true href=#use-the-socket-programming-api>#</a></h3>
<p>One of the easiest ways to convert between byte orderings is to use the socket programming API which comes with a set of handy functions</p>
<ul>
<li><a href=https://linux.die.net/man/3/htons><code>uint16_t htons(uint16_t hostshort)</code></a> - converts host byte order to network byte order.</li>
<li><a href=https://linux.die.net/man/3/ntohs><code>uint16_t ntohs(uint16_t hostshort)</code></a> - converts network byte order to host byte order.</li>
</ul>
<p>The network byte order is always big-endian by convention.</p>
<p>If your system is little-endian (host byte order) the above functions will perform the necessary byte swapping otherwise they just return the same value.</p>
<p>Similarly, <a href=https://linux.die.net/man/3/htonl><code>htonl</code></a> and <a href=https://linux.die.net/man/3/ntohl><code>ntohl</code></a> handles a 32-bit word.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt; // htonl</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt; // uint32_t and uint8_t</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#75715e>/*
</span><span style=color:#75715e>The expected output on a little-endian system:
</span><span style=color:#75715e>
</span><span style=color:#75715e>00EEFFAA
</span><span style=color:#75715e>AAFFEE00
</span><span style=color:#75715e>
</span><span style=color:#75715e>*/</span>


<span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>show_memory_representation</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span> firstbyte,<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> length){
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>length;<span style=color:#f92672>++</span>i){
        printf(<span style=color:#e6db74>&#34;%.2X&#34;</span>,<span style=color:#f92672>*</span>(firstbyte <span style=color:#f92672>+</span> i));
    }
    printf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
    <span style=color:#66d9ef>uint32_t</span> hostlong <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xAAFFEE00</span>;
    <span style=color:#66d9ef>uint32_t</span> netlong;
    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>hostlong,<span style=color:#66d9ef>sizeof</span>(hostlong));
    netlong <span style=color:#f92672>=</span> htonl(hostlong);
    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>netlong,<span style=color:#66d9ef>sizeof</span>(netlong));
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

</code></pre></div><h3 id=use-boostendian-library>Use <code>Boost.Endian</code> library<a hidden class=anchor aria-hidden=true href=#use-boostendian-library>#</a></h3>
<p>The <a href=https://www.boost.org/>Boost</a> library offers a rich set of function to manipulate the endianness of integers and user-defined types.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt; // uint8_t,uint32_t</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;boost/endian/conversion.hpp&gt; // order, endian_reverse</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#75715e>/*
</span><span style=color:#75715e>
</span><span style=color:#75715e>Output on a little endian system:
</span><span style=color:#75715e>
</span><span style=color:#75715e>Little-Endian
</span><span style=color:#75715e>Native order:
</span><span style=color:#75715e>DDCCBBAA
</span><span style=color:#75715e>Native order reversed:
</span><span style=color:#75715e>AABBCCDD
</span><span style=color:#75715e>Native order converted to big endian:
</span><span style=color:#75715e>AABBCCDD
</span><span style=color:#75715e>Native order converted to little endian:
</span><span style=color:#75715e>DDCCBBAA
</span><span style=color:#75715e>Little-endian order converted to native:
</span><span style=color:#75715e>DDCCBBAA
</span><span style=color:#75715e>Big-endian order converted to native:
</span><span style=color:#75715e>DDCCBBAA
</span><span style=color:#75715e>
</span><span style=color:#75715e>*/</span>

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>show_memory_representation</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span> firstbyte,<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> length){
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>length;<span style=color:#f92672>++</span>i){
        printf(<span style=color:#e6db74>&#34;%.2X&#34;</span>,<span style=color:#f92672>*</span>(firstbyte <span style=color:#f92672>+</span> i));
    }
    printf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
}


<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){

    <span style=color:#75715e>// testing the endianness
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(boost<span style=color:#f92672>::</span>endian<span style=color:#f92672>::</span>order<span style=color:#f92672>::</span>native <span style=color:#f92672>==</span> boost<span style=color:#f92672>::</span>endian<span style=color:#f92672>::</span>order<span style=color:#f92672>::</span>big){
            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Big-Endian&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    }<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(boost<span style=color:#f92672>::</span>endian<span style=color:#f92672>::</span>order<span style=color:#f92672>::</span>native <span style=color:#f92672>==</span> boost<span style=color:#f92672>::</span>endian<span style=color:#f92672>::</span>order<span style=color:#f92672>::</span>little){
            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Little-Endian&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    }

    <span style=color:#75715e>// word is in native byte order
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> word <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xAABBCCDD</span>;
    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Native order:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>word,<span style=color:#66d9ef>sizeof</span>(word));

    <span style=color:#75715e>// reverses the current order
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> reversed_word <span style=color:#f92672>=</span> boost<span style=color:#f92672>::</span>endian<span style=color:#f92672>::</span>endian_reverse(word);
    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Native order reversed:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>reversed_word,<span style=color:#66d9ef>sizeof</span>(reversed_word));

    <span style=color:#75715e>// converts native order to big endian
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> big_word <span style=color:#f92672>=</span> boost<span style=color:#f92672>::</span>endian<span style=color:#f92672>::</span>native_to_big(word);
    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Native order converted to big endian:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>big_word,<span style=color:#66d9ef>sizeof</span>(big_word));

    <span style=color:#75715e>// converts native order to little endian
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> little_word <span style=color:#f92672>=</span> boost<span style=color:#f92672>::</span>endian<span style=color:#f92672>::</span>native_to_little(word);
    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Native order converted to little endian:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>little_word,<span style=color:#66d9ef>sizeof</span>(little_word));

    <span style=color:#75715e>// converts little endian order to native
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> native_word <span style=color:#f92672>=</span> boost<span style=color:#f92672>::</span>endian<span style=color:#f92672>::</span>little_to_native(little_word);
    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Little-endian order converted to native:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>native_word,<span style=color:#66d9ef>sizeof</span>(native_word));

    <span style=color:#75715e>// converts big endian order to native
</span><span style=color:#75715e></span>    native_word <span style=color:#f92672>=</span> boost<span style=color:#f92672>::</span>endian<span style=color:#f92672>::</span>big_to_native(big_word);
    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Big-endian order converted to native:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>native_word,<span style=color:#66d9ef>sizeof</span>(native_word));

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

</code></pre></div><p>I think the example program is pretty much self-explanatory and <code>Boost.Endian</code> comes with a lot of bells and whistles. Therefore covering all of them in a single blog post is impossible. You can find the official documentation <a href=https://www.boost.org/doc/libs/1_61_0/libs/endian/doc/index.html>here</a> for more details.</p>
<h3 id=build-your-own-container>Build your own container<a hidden class=anchor aria-hidden=true href=#build-your-own-container>#</a></h3>
<p>If you need even more control, you could just use a standard C++ <code>union</code> to roll out your own.</p>
<p>Here, we are using the property of a <code>union</code> which shares the allocated memory between all of its elements. Which means it can only hold one of its non-static data members at any given time.</p>
<p>We will also use some operator overloading to make things simpler.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt; //uint8_t, uint32_t</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#75715e>/*
</span><span style=color:#75715e>The expected output on a little-endian system:
</span><span style=color:#75715e>
</span><span style=color:#75715e>Actual memory representation:
</span><span style=color:#75715e>DDCCBBAA
</span><span style=color:#75715e>Expecting little-endian, storing as big-endian
</span><span style=color:#75715e>AABBCCDD
</span><span style=color:#75715e>Expecting little-endian, storing as little-endian
</span><span style=color:#75715e>DDCCBBAA
</span><span style=color:#75715e>Expecting big-endian, storing as big-endian
</span><span style=color:#75715e>DDCCBBAA
</span><span style=color:#75715e>Expecting big-endian, storing as little-endian
</span><span style=color:#75715e>AABBCCDD
</span><span style=color:#75715e>*/</span>

<span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>ENDIANNESS</span>{
    little,
    big
};

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T,ENDIANNESS from, ENDIANNESS to<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Word</span>{

    <span style=color:#75715e>/* anonymous union makes sure that the data and
</span><span style=color:#75715e>    ** byte[] occupy the same memory location 
</span><span style=color:#75715e>    */</span>
    <span style=color:#66d9ef>union</span>{
        T data;
        <span style=color:#66d9ef>uint8_t</span> byte[<span style=color:#66d9ef>sizeof</span>(T)];
    };

    <span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span>[](<span style=color:#66d9ef>int</span> i){
        <span style=color:#66d9ef>if</span>(from <span style=color:#f92672>==</span> to){
            <span style=color:#66d9ef>return</span> byte[i];
        }<span style=color:#66d9ef>else</span>{
            <span style=color:#75715e>/* flip the order only if the source and destination has 
</span><span style=color:#75715e>            ** different ordering
</span><span style=color:#75715e>            */</span>
            <span style=color:#66d9ef>return</span> byte[<span style=color:#66d9ef>sizeof</span>(T) <span style=color:#f92672>-</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
        }
    }
};


<span style=color:#75715e>// a helper function to show how the actual memory representatiom
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>show_memory_representation</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span> firstbyte,<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> length){
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>length;<span style=color:#f92672>++</span>i){
        printf(<span style=color:#e6db74>&#34;%.2X&#34;</span>,<span style=color:#f92672>*</span>(firstbyte <span style=color:#f92672>+</span> i));
    }
    printf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){

    Word<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span>,ENDIANNESS<span style=color:#f92672>::</span>little,ENDIANNESS<span style=color:#f92672>::</span>big<span style=color:#f92672>&gt;</span> w;
    Word<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span>,ENDIANNESS<span style=color:#f92672>::</span>little,ENDIANNESS<span style=color:#f92672>::</span>little<span style=color:#f92672>&gt;</span> w1;
    Word<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span>,ENDIANNESS<span style=color:#f92672>::</span>big,ENDIANNESS<span style=color:#f92672>::</span>big<span style=color:#f92672>&gt;</span> w2;
    Word<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span>,ENDIANNESS<span style=color:#f92672>::</span>big,ENDIANNESS<span style=color:#f92672>::</span>little<span style=color:#f92672>&gt;</span> w3;

    <span style=color:#75715e>// our data source which will be using the system endianness in this case
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> source <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xAABBCCDD</span>;

    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Actual memory representation:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;

    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>source,<span style=color:#ae81ff>4</span>);

    <span style=color:#75715e>// to iterate through the data source (could be a file pointer)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>source;

    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span>;<span style=color:#f92672>++</span>i){
        w[i]  <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(ptr <span style=color:#f92672>+</span> i);
        w1[i] <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(ptr <span style=color:#f92672>+</span> i);
        w2[i] <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(ptr <span style=color:#f92672>+</span> i);
        w3[i] <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(ptr <span style=color:#f92672>+</span> i);
    }

    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Expecting little-endian, storing as big-endian&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>w.data,<span style=color:#ae81ff>4</span>);

    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Expecting little-endian, storing as little-endian&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>w1.data,<span style=color:#ae81ff>4</span>);

    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Expecting big-endian, storing as big-endian&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>w2.data,<span style=color:#ae81ff>4</span>);

    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Expecting big-endian, storing as little-endian&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
    show_memory_representation((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>w3.data,<span style=color:#ae81ff>4</span>);

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>You could use it with pretty much any built-in or user-defined datatype. And by no means, this is the best possible implementation out there. This is just something I came up with when I had a requirement. If you know a better way of implementing it, feel free to let me know in the comments.</p>
<p>Thank you for reading! 😀</p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=https://navinmohan.com/openmp-parallel-for-cpp/>
<span class=title>« Prev Page</span>
<br>
<span>Playing around with OpenMP and C++ - Parallelizing for-loops</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Dealing with endianness in C++ on twitter" href="https://twitter.com/intent/tweet/?text=Dealing%20with%20endianness%20in%20C%2b%2b&url=https%3a%2f%2fnavinmohan.com%2fealing-with-endianness-in-c%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Dealing with endianness in C++ on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fnavinmohan.com%2fealing-with-endianness-in-c%2f&title=Dealing%20with%20endianness%20in%20C%2b%2b&summary=Dealing%20with%20endianness%20in%20C%2b%2b&source=https%3a%2f%2fnavinmohan.com%2fealing-with-endianness-in-c%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Dealing with endianness in C++ on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fnavinmohan.com%2fealing-with-endianness-in-c%2f&title=Dealing%20with%20endianness%20in%20C%2b%2b"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Dealing with endianness in C++ on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fnavinmohan.com%2fealing-with-endianness-in-c%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Dealing with endianness in C++ on whatsapp" href="https://api.whatsapp.com/send?text=Dealing%20with%20endianness%20in%20C%2b%2b%20-%20https%3a%2f%2fnavinmohan.com%2fealing-with-endianness-in-c%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Dealing with endianness in C++ on telegram" href="https://telegram.me/share/url?text=Dealing%20with%20endianness%20in%20C%2b%2b&url=https%3a%2f%2fnavinmohan.com%2fealing-with-endianness-in-c%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://navinmohan.com/>Navin Mohan</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>